
\documentclass{article}
\usepackage{natbib} %for easy biblo
\usepackage{hyperref} %for url links
\usepackage{comment} 
\usepackage{color} 

%\VignetteIndexEntry{networkDynamic Example}




\begin{document}

\definecolor{Sinput}{rgb}{0.19,0.19,0.75}
\definecolor{Soutput}{rgb}{0.2,0.3,0.2}
\definecolor{Scode}{rgb}{0.75,0.19,0.19}
\DefineVerbatimEnvironment{Sinput}{Verbatim}{formatcom = {\color{Sinput}}} 
\DefineVerbatimEnvironment{Soutput}{Verbatim}{formatcom = {\color{Soutput}}}
\DefineVerbatimEnvironment{Scode}{Verbatim}{formatcom = {\color{Scode}}} 
\renewenvironment{Schunk}{}{}

\SweaveOpts{concordance=TRUE}

<<foo,include=FALSE,echo=FALSE>>=
options(keep.source = TRUE, width = 60)
foo <- packageDescription("networkDynamic")
@

\title{Package examples for \Sexpr{foo$Package}: \Sexpr{foo$Title} (Version \Sexpr{foo$Version})}  
\author{Ayn Leslie-Cook, Zack Almquist, Pavel N. Krivitsky,\\Skye Bender-deMoll, David R. Hunter\\ Martina Morris, Carter T. Butts}
\maketitle

THIS IS A DRAFT. The package is not complete.

\tableofcontents

\section{Introduction}
The \verb@networkDynamic@ package provides support for a simple family of dynamic extensions to the \verb@network@ \citep*{network} class; these are currently accomplished via the standard \verb@network@ attribute functionality (and hence the resulting objects are still compatible with all conventional routines), but greatly facilitate the practical storage and utilization of dynamic network data. The dynamic extensions are motivated in part by the need to have a consistent data format for exchanging data, storing the inputs and outputs to relational event models, statistical estimation and simulation tools such as \verb@ergm@ \citep*{ergm}and \verb@stergm@, and dynamic visualizations. 

The key features of the package provide basic utilities for working with networks in which:
\begin{itemize}
\item Vertices have `activity' or `existence' status that changes over time (they enter or leave the network)
\item Edges which appear and disappear over time
\item Arbitrary attribute values attached to vertices and edges that change over time
\item Meta-level attributes of the network which change over time
\item Both continuous and discrete time models are supported, and it is possible to effectively blend multiple temporal representations in the same object
\end{itemize}

In addition, the package is primarily oriented towards handling the dynamic network data inputs and outputs to network statistical estimation and simulation tools like \verb@statnet@ and \verb@stergm@. This document will provide a quick overview and use demonstrations for some of the key features. We assume that the reader is already familiar with the use and features of the \verb@network@ package. 

Note: Although \verb@networkDynamic@ shares some of the goals (and authors) of the experimental and quite confusable \verb@dynamicNetwork@ package \citep*{dynamicNetwork}, they are are incompatible.

\section{How to start and end relationships easily}
A very quick condensed example of starting and ending edges to show why it is useful and some of the alternate syntax options.
\subsection{Activating edges}
The standard assumption in the \verb@network@ package and most sociomatrix representations of networks is that an edge between two vertices is either present or absent.  However, many of the phenomena that we wish to describe with networks are dynamic rather than static processes, having a set of edges which change over time.  In some situations the edge connecting a dyad may break and reform multiple times as a relationship is ended and re-established.  The \verb@networkDynamic@ package adds the concept of `activation spells' for each element of a \verb@network@ object. Edges are considered to be present in a network when they are active, and treated as absent during periods of inactivity.  After a relationship has been defined using the normal syntax or network conversion utilities, it can be explicitly activated for a specific time period using the \verb@activate.edges@ methods. Alternatively, edges can be added and activated simultaneously with the \verb@add.edges.active@ helper function.

<<trivial_triangle,include=TRUE,echo=TRUE>>=options(keep.source = TRUE, width = 60)
library(networkDynamic)          # load the dynamic extensions
triangle <- network.initialize(3)  # create a toy network
add.edge(triangle,1,2)    # add an edge between vertices 1 and 2
add.edge(triangle,2,3)               # add a more edges
activate.edges(triangle,at=1) # turn on all edges at time 1 only
activate.edges(triangle,onset=2, terminus=3, 
               e=get.edgeIDs(triangle,v=1,alter=2))
add.edges.active(triangle,onset=4, length=2,tail=3,head=1)
class(triangle)
@

The \verb@onset@ and \verb@terminus@ parameters give the starting and ending point for the activation period (more on this and the \verb@at@ syntax later). When a network object has dynamic elements added, it also gains the \verb@networkDynamic@ class, so it is both a \verb@network@ and \verb@networkDynamic@ object. Notice that the method refers to the relationship using the \verb@e@ argument to specify the ids of the edges to activate. To be safe, we are looking up the ids using the \verb@get.edgeIDs@ method with the \verb@v@ and \verb@alter@ arguments indicating the ids of the vertices involved in the edge. After the activity spells have been defined for a network, it is possible to extract views of the network at arbitrary points in time using the \verb@network.extract@ function in order to calculate traditional graph statistics. 


\subsection{Extracting a network}

<<triangle_degree,include=TRUE,echo=TRUE>>=options(keep.source = TRUE, width = 60)
degree<-function(x){as.vector(rowSums(as.matrix(x))
             +colSums(as.matrix(x)))} # handmade degree function
degree(triangle)  # degree of each vertex, ignoring time
degree(network.extract(triangle,at=0)) 
degree(network.extract(triangle,at=1)) # just look at t=1
degree(network.extract(triangle,at=2))
degree(network.extract(triangle,at=5))
degree(network.extract(triangle,at=10))
@

At time 1, the vertex degrees match what would be expected for the `timeless' network, but for the other time points the degrees are quite different. When the network was sampled outside of the defined time range (at 0 and 10) it returned degrees of 0, suggesting that no edges are present at all. It may be helpful to plot the networks to help understand what is going on. Figure~\ref{fig:fig1} (page~\pageref{fig:fig1}) shows the result of the standard plot command (plot.network.default) for the triangle, as well as plots of the network at specific time points.
<<label=fig1,include=FALSE>>=
par(mfrow=c(2,2))   #show multiple plots
plot(triangle,main='ignoring dynamics',displaylabels=T)  
plot(network.extract(
  triangle,onset=1,terminus=2),main='at time 1',displaylabels=T)
plot(network.extract(
  triangle,onset=2,terminus=3),main='at time 2',displaylabels=T)
plot(network.extract(
  triangle,onset=5,terminus=6),main='at time 5',displaylabels=T)
@
\begin{figure}
\begin{center}
<<label=fig1,fig=TRUE,echo=FALSE>>=
<<fig1>>
@
\end{center}
\caption{Network plot of our trivial triangle network}
\label{fig:fig1}
\end{figure}



\section{Birth, Death, Reincarnation and other ways for vertices to enter and leave networks}
\subsection{Activating vertices}
Many network models need the ability to specify activity spells for vertices in order to account for changes in the population due to `vital dynamics' (births and deaths) or other types of entrances and exists from the sample population. In \verb@networkDynamc@ activity spells for a vertex can be specified using the \verb@activate.vertices@ methods. Like edges, vertices can have multiple spells of activity. If we build on the triangle example:

<<triangle_vert_activate,include=TRUE,echo=TRUE>>=options(keep.source = TRUE, width = 60)
activate.vertices(triangle,onset=1,terminus=5,v=1) 
activate.vertices(triangle,onset=1,terminus=10,v=2)
activate.vertices(triangle,onset=4,terminus=10,v=3)
network.size(network.extract(triangle,at=1)) # how big is it?
network.size(network.extract(triangle,at=4))
network.size(network.extract(triangle,at=5))
@
Using the \verb@network.size@ function on extracted networks shows us that specifying the activity ranges has effectively changed the sizes (and corresponding vertex indices, more on that later) of the network.  Notice also that we've created contradictions in the definition of this hand-made network, for example stating that vertex 3 isn't active until time 4 when earlier we said that there were ties between all nodes at time 1.  The package does not prohibit these kinds of paradoxes, but it does provide a utility to check for them.

<<triangle_check,include=TRUE,echo=TRUE>>=options(keep.source = TRUE, width = 60)
network.dynamic.check(triangle)
@
\subsection{Deactivating elements}
In this case, we can resolve the contradictions by explicitly deactivating the edges involving vertex 3:
<<triangle_deactivate,include=TRUE,echo=TRUE>>=options(keep.source = TRUE, width = 60)
deactivate.edges(triangle,onset=1,terminus=4,
          e=get.edgeIDs(triangle,v=3,neighborhood="combined"))
network.dynamic.check(triangle)
@
The deactivation methods for vertices,\verb@deactivate.vertices@, works the same way, but it accepts a \verb@v=@ parameter to indicate which vertices should be modified instead of the \verb@e=@ parameter. 

\section{`Spells': the magic under the hood}
In which we provide a brief glimpse into the underlying data structures.
\subsection{How we save time}
There are many possible ways of representing change in an edgeset over time. Several of the most commonly used are:
\begin{itemize}
  \item A series of networks or network matrices representing the state of the network at sequential time points
  \item An initial network and a list of edge toggles representing changes to the network at specific time points
  \item A collection of `spell' intervals giving the onset and termination times of each element in the network
\end{itemize}

This package uses the spell representation, and stores the spells as perfectly normal but specially named \verb@active@ attributes on the network. These attributes are a 2-column spell matrix in which the first column gives the onset, the second the terminus, and each row defines an additional activity spell for the network element. For more information, \verb@?activity.attribute@. As an example, to peek at the spells defined for the vertices:

<<triangle_get_times,include=TRUE,echo=TRUE>>=options(keep.source = TRUE, width = 60)
get.vertex.activity(triangle) # vertex spells
get.edge.activity(triangle) # edge spells
@

Notice that the first edge has a 2-spell matrix where the first spell extends from time 1 to time 1 (a zero-duration or instantaneous spell), and the second from time 2 to time 3 (a `unit length` spell. More on this below). The third edge has the interesting special spell \verb@c(Inf,Inf)@ defined to mean `never active` which was produced when we deleted the activity associated with the 3rd edge.   

Within this package, spells are assumed to be `right-open' intervals, meaning that the spell includes its lower bound but not its upper bound. For example, the spell [2,3) covers the range between t>=2 and t<3. Another way of thinking of it is that terminus=`until', the spell ranges from 2 until 3, but does not include 3.

Although it would certainly be possible to directly modify the spells stored in the \verb@active@ attributes, it is much safer to use the various \verb@activate.@ and \verb@deactivate@ methods to ensure that the spell matrix remains in a correctly defined state. The goal of this package is to make it so that it rarely necessary to work with spells, or even worry very much about the underlying data structures. It should be possible to use the provided utilities to convert between the various representations of dynamic networks. However, even if the details of data structure can be ignored, it is still important to be very clear about the underlying temporal model of the network you are working with. 

One of the features that makes the \verb@network@ package so flexible is that it allows ``multiplex'' edges. This means that a pair (or set ...) of vertices can be linked by multiple edges. Often this is used as a way to store several different kinds of relations within the same network object. It is important to be clear that, as we have defined it, having multiplex edges between vertices is not the same thing as an edge with multiple activity spells.  Infact, it is entirely possible to activate the multiplex edges to attach (possibly conflicting) spell information. There are even a few situations where this an appropriate and useful representation.

\section{Differences between Discrete and Continuous data}
Its 2 am on Tuesday.  Do you know what your temporal model is?  Does 2am mean 2:00 am, or from 2:00 to 2:59:59?  And other existential questions.  The differences between at and onset, terminus syntax.

There are two different approaches to representing time when measuring something. 
\subsection{You might be discrete if...}
The `discrete' model thinks of time as equal chunks, ticks, discrete steps, or panels. To measure something we count up the value of interest for that chunk. Time is a series of integers. We can refer to the 1st step, the 365th step, but there is no concept of ordering of events within steps and we can't have fractional steps. A discrete time simulation can never move its clock forward by half-a-tick. As long as the steps can be assumed to be the same duration, there is no need to worry about what the duration actually is. This model is very common in the traditional social networks world. Egocentric survey data may aggregated into a set of weekly network `panels', each of which is though of as a discrete time step in the evolution of the network. We ignore the exact timing of what minute each survey was completed, so that we can compare the week-to-week dynamics. 
\subsection{You might be continuous if...}
In a `continuous' model, measurements are thought of as taking place and an instantaneous point in time (as precisely as can be reasonably measured). Events can have specific durations, but they will almost never be integers. Instead of being present in week 1 and absent in week 2 a relationship starts on Tuesday at 7:45pm and ends on Friday at 10:01am. Continuous time models are useful when the the ordering of events is important.  It still may be useful to represent observations in panels, but we must assume that the state of the network could have changed between our observation at  noon on Friday of week 1 and noon on Friday of week 2. 

Although underlying data model for the \verb@networkDynamic@ package is continuous time, discrete time models can easily be represented. But it is important to be clear about what model you are using when interpreting measurements. For example, the \verb@activate.vertex@ methods can be called using an \verb@onset=t@ and \verb@terminus=t+1@ style, or an \verb@at=t@ style (which converts internally to \verb@onset=t@ , terminus=t). Here are several ways of representing the similar time information for an edge lasting two time steps which give different results:

<<discrete_vs_cont,include=TRUE,echo=TRUE>>=options(keep.source = TRUE, width = 60)

disc <- network.initialize(2)
disc[1,2]<-1
activate.edges(disc,onset=4,terminus=6) # terminus = t+1
is.active(disc,at=4,e=1)
is.active(disc,at=5,e=1)
is.active(disc,at=6,e=1)

cont <- network.initialize(2)
cont[1,2]<-1
activate.edges(cont,onset=4,terminus=5)
is.active(cont,at=4,e=1)
is.active(cont,at=5,e=1)

cont <- network.initialize(2)
cont[1,2]<-1
activate.edges(cont,onset=3.0,terminus=5.0001)
is.active(cont,at=4,e=1)
is.active(cont,at=5,e=1)

point <- network.initialize(2) # continuous waves
point[1,2]<-1
activate.edges(point,at=4)
activate.edges(point,at=5)
is.active(point,at=4,e=1)
is.active(point,at=4.5,e=1) # this doesn't makes sense
is.active(point,at=5,e=1)
@

\section{Show me how it was: extracting static views of dynamic networks }
Working with spells correctly can be complex, so the package provides utility methods for dynamic versions of common network operations. View the help page at \verb@?network.extensions@ for full details and arguments.
\subsection{Testing for activity}
As is probably already apparent, the activity range of a vertex, set of vertices, edge, or set of edges can be tested using the \verb@is.active@ method.
<<is_active,include=TRUE,echo=TRUE>>=options(keep.source = TRUE, width = 60)
is.active(triangle, onset=1, length=1,v=2:3)
is.active(triangle, onset=1, length=1,e=get.edgeIDs(triangle,v=1))
@

\subsection{Listing active elements}
Depending on the end use,  a more convenient way to express these queries might by to use utility functions to retrieve the ids of the network elements of interest that are active for that time range.
<<get_active,include=TRUE,echo=TRUE>>=options(keep.source = TRUE, width = 60)
get.edgeIDs.active(triangle, onset=2, length=1,v=1)
get.neighborhood.active(triangle, onset=2, length=1,v=1)
is.adjacent.active(triangle,vi=1,vj=2,onset=2,length=1)
@
These methods of course accept the same additional arguments as their \verb@network@ counterparts.
\subsection{Basic descriptives}
In some contexts, especially writing simulations on a network that can work in both discrete and continuous time, it may be important to know all the time points at which the structure of the network changes.  The package includes a function \verb@get.change.times@ that can return a list of times for the entire network, or edges and vertices independently:

<<get_change_times,include=TRUE,echo=TRUE>>=options(keep.source = TRUE, width = 60)
get.change.times(triangle)
get.change.times(triangle,vertex.activity=FALSE)
get.change.times(triangle,edge.activity=FALSE)
@

We have also implemented dynamic versions of the basic network functions \verb@network.size@ and \verb@network.edgecount@ which accept the standard activity parameters:

<<size_and_edgecount,include=TRUE,echo=TRUE>>=options(keep.source = TRUE, width = 60)
network.size.active(triangle,onset=2,terminus=3)
network.edgecount.active(triangle,at=5)
@

\subsection{Wiping the slate: removing activity information}
Most \verb@network@ methods will ignore the timing information on a \verb@networkDynamic@ object. However, there may be situations where it is desireable to remove all of the timing information attached to a \verb@networkDynamic@ object.  (Note: this is not the same thing as deactivating elements of the network.) This can be done using the \verb@delete.edge.activity@ and \verb@delete.vertex.activity@ functions which do accept arguments to specifiy which elements should have the timing information deleted.

<<delete_times,include=TRUE,echo=TRUE>>=options(keep.source = TRUE, width = 60)
delete.edge.activity(triangle)
delete.vertex.activity(triangle)
get.change.times(triangle)
@

Although the timing information of the edges and/or vertices may be removed,  other \verb@networkDynamic@ methods will assume activity or inactivity across all time points, based on the argument \verb@active.default@.



\subsection{Differences between `any' and `all' aggregation rules}
In addition to the point-based (\verb@at@ syntax) or unit interval (\verb@length=1@) activity tests and extraction operations used in most examples so far, the methods also support the idea of a `query spell' specified using the same onset and terminus syntax. So it is also possible (assuming it makes sense for the network being studied) to use \verb@length=27.52@ or \verb@onset=0, terminus=256@ Querying with a time range does raise an issue: how should we handle situations where edges or vertices have spells that begin or end part way through the query spell? Although other potential rules have been proposed, the methods currently include a \verb@rule@ argument that can take the values of \verb@any@ (the default) or \verb@all@. The former returns elements if they are active for any part of the query spell, and the later only returns elements if they are active for the entire range of the query spell.  

<<any_all,include=TRUE,echo=TRUE>>=options(keep.source = TRUE, width = 60)
query <- network.initialize(2)
query[1,2] <-1
activate.edges(query, onset=1, terminus=2)
is.active(query,onset=1,terminus=2,e=1)
is.active(query,onset=1,terminus=3,rule='all',e=1)
is.active(query,onset=1,terminus=3,rule='any',e=1)
@

\subsection{Stergm Example}
COULD copy stergm example like in the ndtv package vignette, but since it uses \verb@tergm@, which depends on \verb@networkDynamic@, wouldn't adding it here create a circular package dependency?

\section{But my data are panels of network matrices...}
How to get there from here. Some handy conversion tools for common representations of dynamics.

\subsection{Converting from a list of networks}
Researchers frequently have network data in the form of network panels or `stacks' of network matrices. The \verb@networkDynamic@ package includes one such classic dynamic network dataset in this format: Newcomb's Fraternity Networks. The data are 14 panel observations of friendship preference rankings among fraternity members in a 1956 sociology study. For more details, run  \verb@?newcomb@. This network is a useful example because it has edge weights that change over time and the \verb@newcomb.rank@ version has asymetric rank choice ties. Although this release of the \verb@networkDynamic@ package support dynamic edge attributes, the import utilities yet don't support edge wights.
<<newcomb,eval=TRUE,include=TRUE,echo=TRUE>>=options(keep.source = TRUE, width = 60)
require(networkDynamic)
data(newcomb)             # load the data
names(newcomb)            # its some kind of named list object
length(newcomb)   # how many networks?
is.network(newcomb[[1]]) # is it really a network?
as.sociomatrix(newcomb[[1]]) # peek at sociomatrix       
newcombDyn <- networkDynamic(network.list=newcomb)  # make dynamic  
get.change.times(newcombDyn)
@
When converting panel data in this form, \verb@as.networkDynamic@ assumes that the panels should be assigned times of unit intervals, so the first panel is given the spell [0,1), the second [1,2), etc. This is important because if you use ``at'' query syntax the time does not correspond to the panel index. 
<<newcomb2>>=
all(as.sociomatrix(newcomb[[5]]) == 
      as.sociomatrix(network.extract(newcombDyn,at=5)))
all(as.sociomatrix(newcomb[[5]]) == 
      as.sociomatrix(network.extract(newcombDyn,at=4)))

@


 
\subsection{Converting from initial network and array of toggle times}


\subsection{Converting a dynamic network to timed edge spell list}
<<newcomb>>=
newcombEdgeSpells<-as.data.frame(newcombDyn)
dim(newcombEdgeSpells) # how big is it?
newcombEdgeSpells[1:5,] # peek at the beginning
@
The first two columns of the spell matrix gives the network indices of the vertices involved in the edge, and the next two give the onset and terminus for the spell.  The \verb@right.censored@ column indicates if a statistical estimation process using this spell list should assume that the the entire duration of the edge's activity is included or if it was partially censored by the observation.  The \verb@duration@ column gives the total duration for the specific spell of the edge, not the entire edge duration. 


\section{A streaming data example: McFarland's classroom interactions}

The \verb@networkDynamic@ function can create network dynamic objects from data.frames. It assumes that the first two columns  give the onset and terminus of a spell, and the third and forth columns correspond to the network indices of the ego and alter vertices for that dyad. Multiple spells per dyad are expressed by multiple rows. In the following example, we read some tabular data describing arc relationships out of example text files.  For more information about the dataset (which also exists as a \verb@networkDynamic@ object) see \verb@?cls33_10_16_96@.


<<file_spells>>=
vertexData <-read.table(system.file('extdata/cls33_10_16_96_vertices.tsv', 
            package='networkDynamic'),,header=T)
vertexData[1:5,] # peek
edgeData <-read.table(system.file('extdata/cls33_10_16_96_edges.tsv', 
            package='networkDynamic'),header=T)
edgeData[1:5,] # peek
@

Now that the spell data is loaded in, we need to form it into a network. We want to use the \verb@vertex\_id@,\verb@start\_minute@ and \verb@end\_minute@ from the vertex data, and the \verb@from\_vertex\_id@,\verb@to\_vertex\_id@,\verb@start\_minute@ and \verb@end\_minute@ from the edge data. Since the columns are not in the order that we want, we reorder the column indices when passing to the \verb@edge.spells@ and the \verb@vertex.spells@ arguments of \verb@networkDynamic@.
<<assemble_mcfarland>>=
classDyn <- networkDynamic(vertex.spells=vertexData[,c(3,4,1)],
                           edge.spells=edgeData[,c(3,4,1,2)])
@

The data include some attribute information for the vertices which we'd like to add, but first we need to check if it is dynamic or not. We will assume that if each \verb@vertex\_id@ has only one row, the attributes have only one spell associated with them and can be treated as static. We also must make sure the vertex\_ids are in order. Since \verb@read.table@ creates a \verb@data.frame@ object, we explicity convert factors to character values.

<<mcfarland_vertattr>>=
nrow(vertexData)==length(unique(vertexData$vertex_id))
set.vertex.attribute(classDyn,"data_id",vertexData$data_id)
set.vertex.attribute(classDyn,"sex",as.character(vertexData$sex))
set.vertex.attribute(classDyn,"role",as.character(vertexData$role))
@

If we peek at the change times of the network, it appears that it is certainly not a discrete time network.
<<checkDiscrete>>=
get.change.times(classDyn)[1:10]
@

This mean that to run standard network measures we will need to first ``bin'' or ``slice'' the network up into static networks. Although there is not yet a utility function for this operation, we will convert the classroom data into series of networks, each of which aggregates 5 minutes of streaming interactions. We do this by creating a list of times, and then using the \verb@lapply@ function to apply \verb@network.extract@ for each of those times.

<<classroom_binning>>=
startTimes <-seq(from=0,to=40,by=5) # make a list of times 
classNets <- lapply(startTimes, function(t){ 
  network.extract(classDyn,onset=t,terminus=t+5)})
classMats <- lapply(classNets,as.sociomatrix) # make into matrices
classDensity <- sapply(classNets, network.density) 
plot(classDensity,type='l',xlab='network slice #',ylab='density')
@

Since this dataset consits of continuous time streams of relational information, the choice of 5 minutes is fairly arbitrary. Other durations will reveal dynamics at various timescales. 

<<class_plots,fig=TRUE>>=
par(mfrow=c(2,2))   # show multiple plots
plot(network.extract(
  classDyn,onset=0,length=40,rule="any"),
  main='entire 40 min class period',displaylabels=T)
plot(network.extract(
  classDyn,onset=0,length=5,rule="any"),
  main='a 5 min chunk',displaylabels=T)
plot(network.extract(
  classDyn,onset=0,length=2.5,rule="any"),
  main='a 2.5 min chunk',displaylabels=T)
plot(network.extract(
  classDyn,onset=0,length=.1,rule="any"),
  main='a single conversation turn',displaylabels=T)
@



\section{Dynamic attributes}
Clearly an essential feature of dynamic networks is the ability to express time-varying attributes for networks, vertices (changing properties) and edges (changing weights). In the \verb@networkDynamic@ package we refer to these as dynamic attributes or ``TEAs'' (Temporally Extended Attributes). A TEA is a standard edge, vertex, or network attribute that has a name ending in ``.active'' and carries meta-data regarding its state over time. We store the TEAs as a two-part list, where the first part is a list of values, and the second is a spell matrix giving the values respective time periods of activity. See \verb@?activate.vertex.attribute@ for the full specification of Temporally Extended Attributes. Of course we try to hide most of this as much as possible using a set of accessor functions. 

\subsection{Activating TEA attributes}
The functions for creating TEA attributes are named similarly to the regular functions for manipulating network, vertex, and edge attributes but they also accept the spell-related arguments (onset, terminus, at, length).
<<tea1,eval=TRUE,include=TRUE,echo=TRUE>>=options(keep.source = TRUE, width = 60)
net <-network.initialize(5)
activate.vertex.attribute(net,"happiness", -1, onset=0,terminus=1)
activate.vertex.attribute(net,"happiness", 5, onset=1,terminus=3)
activate.vertex.attribute(net,"happiness", 2, onset=4,terminus=7)
list.vertex.attributes(net)    # what arey they actually named?
get.vertex.attribute.active(net,"happiness",at=2)
get.vertex.attribute(net,"happiness.active",unlist=FALSE)[[1]]
@

Notice that when using the \verb@activate.vertex.attribute@ and \verb@get.vertex.attribute.active@ functions we don't have to include the ``.active'' part of the attribute name, it handles that on its own. When we used the regular \verb@get.vertex.attribute@ function to peek at the attribute of the first vertex we can see the list of values (-1,5,2) and the spell matrix.  We also had to include the \verb@unlist=FALSE@ argument so that it didn't mangle the list object by smooshing into a vector when it was returned. 

There are similar activation functions for edge and network-level attributes.
<<tea1.1>>=
activate.network.attribute(net,'colors',list("red","green","blue","gray"),
                           onset=c(0,1,2,3),terminus=c(1,2,3,4))
add.edges(net,tail=c(1,2,3),head=c(2,3,4)) # need edges to activate
activate.edge.attribute(net,'weight',c(5,12,7),onset=1,terminus=3)
activate.edge.attribute(net,'weight',c(1,2,1),onset=3,terminus=7)
@
Since we didn't give the edges themselves timing info, they will be assumed to be always active. But we've specified that the 'weight' of the edges should vary over time. 

\subsection{Querying TEA attributes}
What happens when there are no values defined? When we activate the vertex attributes, we left a gap in the spell coverage. What happens if we ask for values in the time period?
<<tea2,eval=TRUE,include=TRUE,echo=TRUE>>=options(keep.source = TRUE, width = 60)
get.vertex.attribute.active(net,"happiness",at=3.5)
get.vertex.attribute.active(net,"happiness",onset=2.5,terminus=3.5)
get.vertex.attribute.active(net,"happiness",onset=2.5,terminus=3.5,rule="all")
@
In the first case, no values are defined so \verb@NA@ is returned. In the second case, the query spell included part of a defined value since inclusion rule defaults to `\verb@rule='any'@ and the query intersected with part of the spell associated with the value 5. We can ask it to only return values if they match the entire query spell by setting \verb@rule='all'@, which is what happened in the third case.  

The functions also make it possible have a query that will intersect with multiple values. This returns a value, but also gives a warning that the value returned may not be the appropriate value for the time range. 
<<tea2, results=verbatim>>=
get.vertex.attribute.active(net,"happiness",onset=2.5,terminus=4.5)
@
<<tea3, eval=TRUE,echo=FALSE>>=
cat('Warning message:
In get.vertex.attribute.active(net, "happiness", onset = 2.5, 
    terminus = 4.5) : Multiple attribute values matched query 
    spell  for some vertices, only earliest value used')
@
 In many cases the user might want do aggregate the values together in some way, but that there is no way for the query function know what the correct aggregation method would be--especially if the attributes have categorical rather than numeric values. Should the results be a sum? An average? A time-weighted average? A value chosen at random?   In order to handle these cases correctly, code must be designed to explicty handle the multiple values. To facilitate this the query functions have an argument \verb@return.tea=TRUE@ which can be set so that they will return the (appropriately trimed) TEA structure to be evaluated. 
<<tea4>>=
get.vertex.attribute.active(net,"happiness",onset=2.5,terminus=4.5,
                        return.tea=TRUE)[[1]]
@
If we wanted to calculate the sum value for an attribute over a particular time range
<<tea5>>=
sapply(get.vertex.attribute.active(net,"happiness",onset=0,terminus=7,
                  return.tea=TRUE),function(splist){
                     sum(unlist(splist[[1]]))
                  })
@

The query syntax for network objects is similar to the vertex case \verb@get.network.attribute.active@.  However, in keeping with the pattern established by \verb@network@, the query function for edge TEAs is named \verb@get.edge.value.active@.
<<tea5.1>>=
get.edge.value.active(net,'weight',at=2)
get.edge.value.active(net,'weight',at=5)
@

There are are also functions for checking if TEA attributes are present at any point in time.
<<listtea>>=
list.vertex.attributes.active(net,at=2)
@

\subsection{Modifying TEAs}
The TEA functions are designed to maintain the appropriate sorted representation of attributes and spells even if attributes are not added in temporal order.  So its possible to overwrite the attribute values.

<<tea6>>=
activate.vertex.attribute(net, "happiness",100, onset=0,terminus=10,v=1)
get.vertex.attribute.active(net,"happiness",at=2)
@

Or set attributes to be inactive for specific time ranges and vertices.
<<tea7>>=
deactivate.vertex.attribute(net, "happiness",onset=1,terminus=10,v=2)
get.vertex.attribute.active(net,"happiness",at=2)
@

\section{Making Lin Freeman's windsurfers gossip}
In 1988, Lin Freeman collected a month-long dataset of daily social interactions between windsurfers on California beaches \citep{almquist}, \citep{freeman}. The dataset is included in \verb@networkDynamic@ and has some challenging features, including vertex dynamics (different people are present on the beach on different days) and a missing day of obeservation. (Run \verb@?windsurfers@ for more details). 
<<windsurfers>>=
data(windsurfers)    # let's go to the beach!
range(get.change.times(windsurfers))
sapply(0:31,function(t){ # how many people in net each day?
  network.size.active(windsurfers,at=t)})
@

Although not directly relevent of for the trivial sim we are about to build, the \verb@windsurfers@ network object also as some network-level dynamic attributes that give information about the weather, etc.
<<windsurfers_meta, fig=TRUE>>=
par(mfcol=c(2,1)) # show multiple plots
plot(sapply(0:31,function(t){ # how many people in net each day?
  network.size.active(windsurfers,at=t)}),
     type='l',xlab="number on beach",ylab="day"
)
plot(sapply(0:31,function(t){ # how many people in net each day?
  get.network.attribute.active(windsurfers,'atmp',at=t)}),
     type='l',xlab="air temp",ylab="day"
)
par(mfcol=c(1,1))
@

We will create a very crude model of rumor transmission as an example of a process simulation using dynamic attributes on a network with changing edges and vertices. We will assume that there is a ``rumor'' spreading among the windsurfers. At each time step, they have some probability of passing the rumor to the people they are interacting with on the beach that day. First we define a function run the simulation:

<<windsim>>=
runSim<-function(net,timeStep,transProb){
  # loop through time, updating states
  times<-seq(from=0,to=max(get.change.times(net)),by=timeStep)
  for(t in times){
    # find all the people who know and are active
    knowers <- which(!is.na(get.vertex.attribute.active(
      net,'knowsRumor',at=t,require.active=TRUE)))
    # get the edge ids of active friendships of people who knew
    for (knower in knowers){
      conversations<-get.edgeIDs.active(net,v=knower,at=t)
      for (conversation in conversations){
        # select conversation for transmission with appropriate prob
        if (runif(1)<=transProb){
          # update state of people at other end of conversations
          # but we don't know which way the edge points so..
          v<-c(net$mel[[conversation]]$inl,
                 net$mel[[conversation]]$outl)
          # ignore the v we already know 
          v<-v[v!=knower]
          activate.vertex.attribute(net,"knowsRumor",TRUE,
                                    v=v,onset=t,terminus=Inf)
          # record who spread the rumor
          activate.vertex.attribute(net,"heardRumorFrom",knower,
                                  v=v,onset=t,length=timeStep)
          # record which friendships the rumor spread across
          activate.edge.attribute(net,'passedRumor',
                    value=TRUE,e=conversation,onset=t,terminus=Inf)
        }
      }
    }  
  }
  return(net)
}
@

<<setseed, echo=FALSE>>=
set.seed(123) # so we will get the same results each time the document is built
@
Then we set the paramters and the initial state of the network and run the simulation. 
<<windsim_params>>=
timeStep <- 1  # units are in days
transProb <- 0.2 # how likely to tell in each conversation/day
# start the rumor out on vertex 1
activate.vertex.attribute(windsurfers,"knowsRumor",TRUE,v=1,
                          onset=0-timeStep,terminus=Inf)
activate.vertex.attribute(windsurfers,"heardRumorFrom",1,v=1,
                          onset=0-timeStep,length=timeStep)
windsurfers<-runSim(windsurfers,timeStep,transProb) # run it!
@


We'll make some network plots so we can get an idea of what happend.

<<windsim_plots,fig=TRUE>>=
par(mfcol=c(1,2)) # show two plots side by site
wind7<-network.extract(windsurfers,at=7)
plot(wind7,
     edge.col=sapply(!is.na(get.edge.value.active(wind7,
      "passedRumor",at=7)), function(e){ switch(e+1,"darkgray","red")}),
     vertex.col=sapply(!is.na(get.vertex.attribute.active(wind7,
      "knowsRumor",at=7)), function(v){switch(v+1,"gray","red")}),
     label.cex=0.5,displaylabels=TRUE,main="gossip at time 7")
wind30<-network.extract(windsurfers,at=30)
plot(wind30,
     edge.col=sapply(!is.na(get.edge.value.active(wind30,
      "passedRumor",at=30)),function(e){switch(e+1,"darkgray","red")}),
     vertex.col=sapply(!is.na(get.vertex.attribute.active(wind30,
      "knowsRumor",at=30)),function(v){switch(v+1,"gray","red")}),
     label.cex=0.5,displaylabels=TRUE,main="gossip at time 30")
par(mfcol=c(1,1))
@

Which people heard the rumor halfway through the month? How many heard each day?
<<windsim_stats,fig=TRUE>>=
get.vertex.attribute.active(windsurfers,'knowsRumor',at=15)
plot(sapply(0:31,function(t){
  sum(get.vertex.attribute.active(windsurfers,'knowsRumor',at=t),
      na.rm=TRUE)}),
  main='windsurfers who know',ylab="# people",xlab='time'
)
@

In additiona to extracting values, we can do operations using the TEA attributes directly. We wrote the sim function so that it recorded each time a person was told the rumor.  What are the ids of the people who told person 3? On which days did person 3 hear the rumor?
<<windsim_extract>>=
# pull TEA from v3, extract values from 1st part and unlist
unlist(get.vertex.attribute.active(windsurfers,'heardRumorFrom',
                onset=0,terminus=31,return.tea=TRUE)[[3]][[1]])
# pull TEA from v3, extract times from 2nd part and pull col 1
get.vertex.attribute.active(windsurfers,'heardRumorFrom',
              onset=0,terminus=31,return.tea=TRUE)[[3]][[2]][,1]
@
We can also write a function to create a rumor transmission tree using the `heardRumorFrom' attribute in order to plot out the sequence of conversation steps that spread the gossip. 
<<windsim_tree,fig=TRUE>>=
transTree<-function(net){
  # for each vertex in net who knows
  knowers <- which(!is.na(get.vertex.attribute.active(net,
                                        'knowsRumor',at=Inf)))
  # find out who the first transmission was from
  transTimes<-get.vertex.attribute.active(net,"heardRumorFrom",
                      onset=-Inf,terminus=Inf,return.tea=TRUE)
  # subset to only ones that know
  transTimes<-transTimes[knowers]
  # get the first value of the TEA for each knower
  tellers<-sapply(transTimes,function(tea){tea[[1]][[1]]})
  # create a new net of appropriate size 
  treeIds <-union(knowers,tellers)
  tree<-network.initialize(length(treeIds),loops=TRUE)
  # copy labels from original net
  set.vertex.attribute(tree,'vertex.names',treeIds)
  # translate the knower and teller ids to new network ids   
  # and add edges for each transmission                
  add.edges(tree,tail=match(tellers,treeIds), 
            head=match(knowers,treeIds) )               
  return(tree)                
}
plot(transTree(windsurfers),displaylabels=TRUE,
     label.cex=0.5,label.col='blue',loop.cex=3)
@
We can see that the rumor started at v1, our seed vertex, which has little loop because it infected itself. 

\section{Other Coming Attractions}
ndtv: Network Dynamic Temporal Visualization package -- like TV for your networks. The \verb@ndtv@ package creates network animations of dynamic networks stored in the \verb@networkDynamic@ format. Provides the tools developed in \citep*{dynamicNetwork} but with R methods for building, controling, and rendering out animations. 

\section{Vocabulary definitions}
This is a list of terms and common function arguments giving their special meanings within the context of the \verb@networkDynamic@ package.
\begin{description}
\item [spell] bounded interval of time describing activity period of a network element
\item [onset] beginning of spell
\item [terminus] end of a spell
\item [length] the duration of a spell
\item [at] a single time point, a spell with zero length where onset=terminus
\item [start] begining (least time) of observation period (or series of spells)
\item [end] end (greatest time) of obeservation period (or series of spells)
\item [spell list or spell matrix] a means of describing the activity of a network or network element using a matrix in which one column contains the onsets and another the termini of each spell
\item [toggle list] a means of describing the activity of a network or network element using a list of times at which an element changed state (`toggled')
\item [onset-censord] when elements of a dynamic network are known to be active before start of the defined observation period, even if the onset of the spell is not known.
\item [terminus-censored] when elements of a dynamic network are known to be active after the end of the defined observation period, even if the terminus of the spell is not known.
\item [TEA] Temporally Extended Attribute: structure for storeing dynamic attribute data on vertices, edges, and networks.
\end{description}

\section{Complete package function listing}
Below is a reference list of all the public functions included in the package \verb@networkDynamic@ 
<<package_listing,include=TRUE,echo=TRUE>>=options(keep.source = TRUE, width = 60)
cat(ls("package:networkDynamic"),sep="\n")
@


\begin{thebibliography}{}

\bibitem[Almquist, et al (2011)]{almquist}
Almquist, Zack W. and Butts, Carter T. (2011). 
\newblock Logistic Network Regression for Scalable Analysis of Networks with Joint Edge/Vertex Dynamics.
\newblock \emph{IMBS Technical Report MBS 11-03}, University of California, Irvine. 

\bibitem[Bender-deMoll et al.(2008)]{dynamicNetwork}
Bender-deMoll, S., Morris, M. and Moody, J. (2008)
\newblock Prototype Packages for Managing and Animating Longitudinal Network Data: dynamicnetwork and rSoNIA
\newblock \emph{Journal of Statistical Software} 24:7.

\bibitem[Butts(2008)]{network}
Butts CT (2008). 
\newblock network: A Package for Managing Relational Data in R. 
\newblock \emph{Journal of Statistical Software}, 24(2). \url{http://www.jstatsoft.org/v24/i02/}. 

\bibitem[Hunter et al.(2008b)]{ergm}
Hunter DR, Handcock MS, Butts CT, Goodreau SM, Morris M (2008b). 
\newblock ergm: A Package to Fit, Simulate and Diagnose Exponential-Family Models for Networks. 
\newblock \emph{Journal of Statistical Software}, 24(3). \url{http://www.jstatsoft.org/v24/i03/}. 


\bibitem[Newcomb(1961)]{newcomb} 
Newcomb T. (1961)
\emph{The acquaintance process} New York: Holt, Reinhard and Winston.



\bibitem[Freeman et al (1988)]{freeman}
Freeman, L. C., Freeman, S. C., Michaelson, A. G., (1988)
\newblock On human social intelligence. 
\newblock \emph{Journal of Social Biological Structure} 11, 415-425.

\end{thebibliography}

\end{document}
